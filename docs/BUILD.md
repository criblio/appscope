# AppScope Build System

We use simple Makefiles to build the binaries and run the tests. GitHub Workflows/Actions handle CI. This document explans aspects of both.

## Building

* Running `make all` and `make test` will build the binaries and run the unit tests on the local machine using the OS-supplied libraries and locally installed dependencies; libc, gcc, automake, autoconf, libtool, etc.

  > We only officially support building locally on Ubuntu 18.04 and generate warnings otherwise.

* Run `make clean` to remove built binaries and intermediate files generated by the build and test processes. _This removes all architecture's binaries, not just the local one._

* Run `make builder` to build the "builder" container image. By default it will build the one for the local `ARCH=$(uname -m)` but this can be overridden; i.e. `make builder ARCH=aarch64`. The resulting image will be in the local registry as `criblio/appscope-builder:ubuntu-${ARCH}`. It uses the supported version of Ubuntu and has all the necessary build and debug dependencies pre-installed.

  Run `make builder DIST=alpine` to build an Alpine "builder" image instead of the default Ubuntu version. The image is tagged as `criblio/appscope-builder:alpine-${ARCH}`. This isn't actually used to build in; it's used for debugging and testing in a musl libc environment.

* Run `make build` to build and test the code in the "builder" container. By default it will build for the local `ARCH=$(uname -m)` but this can be overridden; i.e. `make build ARCH=aarch64`. This is the officially supported build mechanism since it enforces the dependency requirements.

  The top-level directory is mounted into the container so it has access to the local code and can put the results into the local `bin/` and `lib/` folders. We match the user's UID/GID in the container so we don't end up with ownership issues.

  It runs `make all test` by default. Set `CMD` to override that; i.e. `make build CMD="make coreall"`.

* Run `make run` to get a shell in the "builder" container. Override `ARCH` to use something other than the `$(uname -m)` default. This is intended to provide a debug platform but it can also be handy to keep open and run `make` without having to start and stop the container every time.

  Run `make exec` to get another shell in the existing container. Set `ARCH` and `DIST` to get the one you want and `CMD` to specify the command to run (defaults to `/bin/bash`).

* Run `make clibuild`, `make clitest`, or any other target that starts with `cli` in the top-level directory and they will be relayed to the corresponding target (without the `cli` prefix) in `cli/Makefile`. We have `make scope` as a shortcut at the top too; an _easy-button_ for the _easy-button_ CLI team.

* The `make docker-build`, `make docker-run`, and `make docker-run-alpine` targets were added a while back to build and run the code in containers instead of the local machine. These are now deprecated in favor of the `build` and `run` targets. They work still but will be removed in the future.

## Design

* The built binaries (`scope`, `libscope.so`, `ldscope`, and `ldscopedyn`) end up in `(bin|lib)/(linux|macOS)/(x86_64|aarch64)/`. The OS and architecure they're built for is in the path, not the filenames.
  
  To make the container building simpler, we have softlinks for Docker's architecture names that point to the `uname -m` versions; i.e. `arm64 -> aarch64` and `amd64 -> x86_64`.

* We use the top-level `Makefile` to build the library and loaders (i.e. the C code) running there in the top-level directory. We don't recursively `cd` down into `src/` or `test/` as some other build system do.

* The top-level `Makefile` detects the local OS and includes `os/linux/Makefile` or `os/macOS/Makefile`. The logic aborts if another OS is detected. It also warns that the MacOS build and Linux builds on anything other than Ubuntu 18.04 are unsupported.

* The `os/linux/Makefile` includes architecture-specific `os/linux/x86_64.mk` or `os/linux/aarch64.mk` files.

* The top-level `Makefile` has a `cli%` pattern rule and relays to coresponding targets in `cli/Makefile`. It `cd`'s into`/cli` to run those targets. We also have a `scope` target as a shortcut to build the CLI from the top-level directory.

* The `cli/Makefile` has targets to build and test the CLI in the `cli/` directory. Standard stuffC in there..

* The `contrib/Makefile` only provides a `clean` target. It's used by `make clean` at the top.

* First prerequisite for multi-architecture builds is to get QEMU going. The `require-qemu-binfmt` target handles installing things if they're not already. See [qemu-user-static] for deatils. Second prequisite is [Docker BuildX]. See that page for getting it setup. In CI, these will be done for us already.

## Notes on Pending Changes

* Timing Info
  * `docker buildx prune` to remove cached builder images
  * `make builder` took 2m18.445s
  * `make builder ARCH=aarch64` took 5m34.032s
  * `make build CMD="make coreall"` took 0m59.942s
  * `make build CMD="make coreall" ARCH=aarch64` took 14m52.233s
* To Do
  * wring out the `image` target
  * add `cdn` target
  * integration tests
  * sudo not working in the Ubuntu/ARM builder for some reason.
* Changes to warn devs about:
  * We no longer include `cli/Makefile` in the top-level `Makefile` because it caused target collisions. Instead, we are using `$(MAKE) -C cli` to build any targets that start with `cli` by `cd`'ing there first. So, `make clifoo` effectively becomes `cd cli && make foo`.
  * The built `scope` binary is no longer being put in `~/go/bin/scope` because of the multi-architecture builds. It's in `bin/$(OS)/$(ARCH)/scope`.
  * Dependencies have been cleaned up or added for various CLI and core targets. There may be surprise noop makes still as these get polished.

[qemu-user-static]: https://github.com/multiarch/qemu-user-static
[Docker BuildX]: https://docs.docker.com/buildx/working-with-buildx/
